/**
 * lalr grammar and lexer rules for kissy xtemplate.
 * @author yiminghe@gmail.com
 */
(function () {
  function popState() {
    this.popState();
  }

  var codeSection = ['p', 'e'];

  return {
    productions: [
      {
        symbol: 'program',
        rhs: ['statements', 'INVERSE', 'statements'],
        action: function () {
          return new this.yy.ProgramNode({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1, this.$3);
        }
      },
      {
        symbol: 'program',
        rhs: ['statements'],
        action: function () {
          return new this.yy.ProgramNode({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1);
        }
      },
      {
        symbol: 'statements',
        rhs: ['statement'],
        action: function () {
          return [this.$1];
        }
      },
      {
        symbol: 'statements',
        rhs: ['statements', 'statement'],
        action: function () {
          var statements = this.$1;
          var statement = this.$2;
          if (statements.length) {
            var lastStatement = statements[statements.length - 1];
            if (lastStatement.rtrim && statement && statement.type === 'contentStatement' && !statement.value.trim()) {
            } else if (statement.ltrim && lastStatement && lastStatement.type === 'contentStatement' && !lastStatement.value.trim()) {
              statements[statements.length - 1] = statement;
            } else {
              statements.push(statement);
            }
          } else {
            statements.push(statement);
          }
        }
      },

      // call block function
      {
        symbol: 'statement',
        rhs: ['OPEN_BLOCK', 'function', 'CLOSE', 'program', 'OPEN_CLOSE_BLOCK', 'id', 'CLOSE'],
        action: function () {
          var program = this.$4;
          var openBlock = this.$1;
          var lastClose = this.$7;
          var statements = program.statements;
          var close = this.$3;
          var openCloseBlock = this.$5;
          if (close.indexOf('~}') !== -1 && statements[0] && statements[0].type === 'contentStatement') {
            if (!statements[0].value.trim()) {
              statements.shift();
            }
          }
          if (openCloseBlock.indexOf('{~') !== -1 && statements[statements.length - 1] && statements[statements.length - 1].type === 'contentStatement') {
            if (!statements[statements.length - 1].value.trim()) {
              statements.pop();
            }
          }
          var statement = new this.yy.BlockStatement({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$2, program, this.$6, this.$1.slice(0, 3) !== '{{{');

          if (openBlock.indexOf('{~') !== -1) {
            statement.ltrim = 1;
          }
          if (lastClose.indexOf('~}') !== -1) {
            statement.rtrim = 1;
          }
          return statement;
        }
      },

      // render expression
      {
        symbol: 'statement',
        rhs: ['OPEN_TPL', 'expression', 'CLOSE'],
        action: function () {
          var openTpl = this.$1;
          var close = this.$3;

          var statement = new this.yy.ExpressionStatement({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$2, this.$1.slice(0, 3) !== '{{{');

          if (openTpl.indexOf('{~') !== -1) {
            statement.ltrim = 1;
          }
          if (close.indexOf('~}') !== -1) {
            statement.rtrim = 1;
          }

          return statement;
        }
      },

      // render literal html content
      {
        symbol: 'statement',
        rhs: ['CONTENT'],
        action: function () {
          return new this.yy.ContentStatement({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1);
        }
      },

      {
        symbol: 'function',
        rhs: ['id', 'L_PAREN', 'params', 'COMMA', 'hash', 'R_PAREN'],
        action: function () {
          return new this.yy.Function({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1, this.$3, this.$5);
        }
      },

      {
        symbol: 'function',
        rhs: ['id', 'L_PAREN', 'params', 'R_PAREN'],
        action: function () {
          return new this.yy.Function({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1, this.$3);
        }
      },
      {
        symbol: 'function',
        rhs: ['id', 'L_PAREN', 'hash', 'R_PAREN'],
        action: function () {
          return new this.yy.Function({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1, null, this.$3);
        }
      },
      {
        symbol: 'function',
        rhs: ['id', 'L_PAREN', 'R_PAREN'],
        action: function () {
          return new this.yy.Function({
            filename: this.lexer.filename,
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1);
        }
      },

      // params start
      {
        symbol: 'params',
        rhs: ['params', 'COMMA', 'param'],
        action: function () {
          this.$1.push(this.$3);
        }
      },
      {
        symbol: 'params',
        rhs: ['param'],
        action: function () {
          return [this.$1];
        }
      },
      {
        symbol: 'param',
        rhs: ['expression']
      },
      // params end

      // expression start
      {
        symbol: 'expression',
        rhs: ['conditionalExpression']
      },
      {
        symbol: 'expression',
        rhs: ['L_BRACKET', 'listExpression', 'R_BRACKET'],
        action: function () {
          return new this.yy.ArrayExpression(this.$2);
        }
      },
      // empty array
      {
        symbol: 'expression',
        rhs: ['L_BRACKET', 'R_BRACKET'],
        action: function () {
          return new this.yy.ArrayExpression([]);
        }
      },
      {
        symbol: 'expression',
        rhs: ['L_BRACE', 'objectExpression', 'R_BRACE'],
        action: function () {
          return new this.yy.ObjectExpression(this.$2);
        }
      },
      // empty object
      {
        symbol: 'expression',
        rhs: ['L_BRACE', 'R_BRACE'],
        action: function () {
          return new this.yy.ObjectExpression([]);
        }
      },
      {
        symbol: 'objectPart',
        rhs: ['STRING', 'COLON', 'expression'],
        action: function () {
          return [this.$1, this.$3];
        }
      },
      {
        symbol: 'objectPart',
        rhs: ['ID', 'COLON', 'expression'],
        action: function () {
          return [this.$1, this.$3];
        }
      },
      {
        symbol: 'objectExpression',
        rhs: ['objectPart'],
        action: function () {
          return [this.$1];
        }
      },
      {
        symbol: 'objectExpression',
        rhs: ['objectExpression', 'COMMA', 'objectPart'],
        action: function () {
          this.$1.push(this.$3);
        }
      },
      {
        symbol: 'listExpression',
        rhs: ['expression'],
        action: function () {
          return [this.$1];
        }
      },
      {
        symbol: 'listExpression',
        rhs: ['listExpression', 'COMMA', 'expression'],
        action: function () {
          this.$1.push(this.$3);
        }
      },
      {
        symbol: 'conditionalExpression',
        rhs: ['conditionalOrExpression']
      },
      {
        symbol: 'conditionalExpression',
        rhs: ['conditionalOrExpression','QUERY','conditionalOrExpression','COLON','conditionalExpression'],
        action: function(){
            return new this.yy.ConditionalExpression(this.$1,this.$3,this.$5);
        }
      },
      {
        symbol: 'conditionalOrExpression',
        rhs: ['conditionalAndExpression']
      },
      {
        symbol: 'conditionalOrExpression',
        rhs: ['conditionalOrExpression', 'OR', 'conditionalAndExpression'],
        action: function () {
          return new this.yy.ConditionalOrExpression(this.$1, this.$3);
        }
      },
      {
        symbol: 'conditionalAndExpression',
        rhs: ['equalityExpression']
      },
      {
        symbol: 'conditionalAndExpression',
        rhs: ['conditionalAndExpression', 'AND', 'equalityExpression'],
        action: function () {
          return new this.yy.ConditionalAndExpression(this.$1, this.$3);
        }
      },
      {
        symbol: 'equalityExpression',
        rhs: ['relationalExpression']
      },
      {
        symbol: 'equalityExpression',
        rhs: ['equalityExpression', 'LOGIC_EQUALS', 'relationalExpression'],
        action: function () {
          return new this.yy.EqualityExpression(this.$1, '===', this.$3);
        }
      },
      {
        symbol: 'equalityExpression',
        rhs: ['equalityExpression', 'LOGIC_NOT_EQUALS', 'relationalExpression'],
        action: function () {
          return new this.yy.EqualityExpression(this.$1, '!==', this.$3);
        }
      },
      {
        symbol: 'relationalExpression',
        rhs: ['additiveExpression']
      },
      {
        symbol: 'relationalExpression',
        rhs: ['relationalExpression', 'LT', 'additiveExpression'],
        action: function () {
          return new this.yy.RelationalExpression(this.$1, '<', this.$3);
        }
      },
      {
        symbol: 'relationalExpression',
        rhs: ['relationalExpression', 'GT', 'additiveExpression'],
        action: function () {
          return new this.yy.RelationalExpression(this.$1, '>', this.$3);
        }
      },
      {
        symbol: 'relationalExpression',
        rhs: ['relationalExpression', 'LE', 'additiveExpression'],
        action: function () {
          return new this.yy.RelationalExpression(this.$1, '<=', this.$3);
        }
      },
      {
        symbol: 'relationalExpression',
        rhs: ['relationalExpression', 'GE', 'additiveExpression'],
        action: function () {
          return new this.yy.RelationalExpression(this.$1, '>=', this.$3);
        }
      },
      {
        symbol: 'additiveExpression',
        rhs: ['multiplicativeExpression']
      },
      {
        symbol: 'additiveExpression',
        rhs: ['additiveExpression', 'PLUS', 'multiplicativeExpression'],
        action: function () {
          return new this.yy.AdditiveExpression(this.$1, '+', this.$3);
        }
      },
      {
        symbol: 'additiveExpression',
        rhs: ['additiveExpression', 'MINUS', 'multiplicativeExpression'],
        action: function () {
          return new this.yy.AdditiveExpression(this.$1, '-', this.$3);
        }
      },
      {
        symbol: 'multiplicativeExpression',
        rhs: ['unaryExpression']
      },
      {
        symbol: 'multiplicativeExpression',
        rhs: ['multiplicativeExpression', 'MULTIPLY', 'unaryExpression'],
        action: function () {
          return new this.yy.MultiplicativeExpression(this.$1, '*', this.$3);
        }
      },
      {
        symbol: 'multiplicativeExpression',
        rhs: ['multiplicativeExpression', 'DIVIDE', 'unaryExpression'],
        action: function () {
          return new this.yy.MultiplicativeExpression(this.$1, '/', this.$3);
        }
      },
      {
        symbol: 'multiplicativeExpression',
        rhs: ['multiplicativeExpression', 'MODULUS', 'unaryExpression'],
        action: function () {
          return new this.yy.MultiplicativeExpression(this.$1, '%', this.$3);
        }
      },
      {
        symbol: 'unaryExpression',
        rhs: ['NOT', 'unaryExpression'],
        action: function () {
          return new this.yy.UnaryExpression(this.$1, this.$2);
        }
      },
      {
        symbol: 'unaryExpression',
        rhs: ['MINUS', 'unaryExpression'],
        action: function () {
          return new this.yy.UnaryExpression(this.$1, this.$2);
        }
      },
      {
        symbol: 'unaryExpression',
        rhs: ['primaryExpression']
      },
      {
        symbol: 'primaryExpression',
        rhs: ['STRING'],
        action: function () {
          return new this.yy.String({
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1);
        }
      },
      {
        symbol: 'primaryExpression',
        rhs: ['NUMBER'],
        action: function () {
          return new this.yy.Number({
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1);
        }
      },
      {
        symbol: 'primaryExpression',
        rhs: ['id']
      },
      {
        symbol: 'primaryExpression',
        rhs: ['L_PAREN', 'expression', 'R_PAREN'],
        action: function () {
          return this.$2;
        }
      },
      // expression end

      // hash start
      {
        symbol: 'hash',
        rhs: ['hash', 'COMMA', 'hashSegment'],
        action: function () {
          this.$1.value.push(this.$3);
        }
      },
      {
        symbol: 'hash',
        rhs: ['hashSegment'],
        action: function () {
          return new this.yy.Hash({
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, [this.$1]);
        }
      },
      {
        symbol: 'hashSegment',
        rhs: ['id', 'EQUALS', 'expression'],
        action: function () {
          return [this.$1, this.$3];
        }
      },
      // hash end

      // path start
      {
        symbol: 'id',
        rhs: ['idSegments'],
        action: function () {
          return new this.yy.Id({
            line: this.lexer.firstLine,
            col: this.lexer.firstColumn
          }, this.$1);
        }
      },
      {
        symbol: 'idSegments',
        rhs: ['function'],
        action: function () {
          return [this.$1];
        }
      },
      {
        symbol: 'idSegments',
        rhs: ['idSegments', 'SEP', 'ID'],
        action: function () {
          this.$1.push(this.$3);
        }
      },
      {
        symbol: 'idSegments',
        rhs: ['idSegments', 'L_BRACKET', 'expression', 'R_BRACKET'],
        action: function () {
          this.$1.push(this.$3);
        }
      },
      {
        symbol: 'idSegments',
        rhs: ['ID'],
        action: function () {
          return [this.$1];
        }
      }
      // path end
    ],
    lexer: {
      // states:
      // t: in tpl mode
      // et: escape tpl
      // e: enter escaped tpl {{
      // p: enter plain tpl {{{
      rules: [
        {
          // "\n".match(/./)
          regexp: /^[\s\S]*?(?={{)/,
          action: function () {
            var self = this,
              text = self.text,
              m,
              n = 0;

            if ((m = text.match(/\\+$/))) {
              n = m[0].length;
            }
            if (n % 2) {
              self.pushState('et');
              text = text.slice(0, -1);
            } else {
              self.pushState('t');
            }
            if (n) {
              text = text.replace(/\\+$/g, function (m) {
                return new Array(m.length / 2 + 1).join('\\');
              });
            }
            // https://github.com/kissyteam/kissy/issues/330
            // return even empty
            self.text = text;
            return 'CONTENT';
          }
        },
        {
          regexp: /^[\s\S]+/,
          token: 'CONTENT'
        },
        {
          state: ['et'],
          token: 'CONTENT',
          regexp: /^[\s\S]{2,}?(?:(?={{)|$)/,
          action: popState
        },
        {
          state: ['t'],
          // support Inverted Sections in mustache
          // support {{@
          regexp: /^{{\{?~?(?:#|@)/,
          token: 'OPEN_BLOCK',
          action: function () {
            var self = this,
              text = self.text;
            if (text.slice(0, 3) === '{{{') {
              self.pushState('p');
            } else {
              self.pushState('e');
            }
          }
        },
        {
          state: ['t'],
          regexp: /^{{\{?~?\//,
          token: 'OPEN_CLOSE_BLOCK',
          action: function () {
            var self = this,
              text = self.text;
            if (text.slice(0, 3) === '{{{') {
              self.pushState('p');
            } else {
              self.pushState('e');
            }
          }
        },
        {
          state: ['t'],
          regexp: /^{{\s*else\s*}}/,
          token: 'INVERSE',
          action: popState
        },
        {
          state: ['t'],
          // ignore comment
          regexp: /^{{![\s\S]*?}}/,
          action: popState
        },
        {
          // literal mode
          state: ['t'],
          regexp: /^{{%([\s\S]*?)%}}/,
          action: function () {
            // return to content mode
            this.text = this.matches[1] || '';
            this.popState();
          },
          token: 'CONTENT'
        },
        {
          state: ['t'],
          regexp: /^{{\{?~?/,
          token: 'OPEN_TPL',
          action: function () {
            var self = this,
              text = self.text;
            if (text.slice(0, 3) === '{{{') {
              self.pushState('p');
            } else {
              self.pushState('e');
            }
          }
        },
        {
          // ignore white space
          state: codeSection,
          regexp: /^\s+/
        },
        {
          state: codeSection,
          regexp: /^,/,
          token: 'COMMA'
        },
        {
          state: ['p'],
          regexp: /^~?}}}/,
          action: function () {
            this.popState(2);
          },
          token: 'CLOSE'
        },
        {
          state: ['e'],
          regexp: /^~?}}/,
          action: function () {
            this.popState(2);
          },
          token: 'CLOSE'
        },
        {
          state: codeSection,
          regexp: /^\(/,
          token: 'L_PAREN'
        },
        {
          state: codeSection,
          regexp: /^\)/,
          token: 'R_PAREN'
        },
        {
          state: codeSection,
          regexp: /^\|\|/,
          token: 'OR'
        },
        {
          state: codeSection,
          regexp: /^&&/,
          token: 'AND'
        },
        {
          state: codeSection,
          regexp: /^===/,
          token: 'LOGIC_EQUALS'
        },
        {
          state: codeSection,
          regexp: /^!==/,
          token: 'LOGIC_NOT_EQUALS'
        },
        {
          state: codeSection,
          regexp: /^>=/,
          token: 'GE'
        },
        {
          state: codeSection,
          regexp: /^<=/,
          token: 'LE'
        },
        {
          state: codeSection,
          regexp: /^>/,
          token: 'GT'
        },
        {
          state: codeSection,
          regexp: /^</,
          token: 'LT'
        },
        {
          state: codeSection,
          regexp: /^\+/,
          token: 'PLUS'
        },
        {
          state: codeSection,
          regexp: /^-/,
          token: 'MINUS'
        },
        {
          state: codeSection,
          regexp: /^\*/,
          token: 'MULTIPLY'
        },
        {
          state: codeSection,
          regexp: /^\//,
          token: 'DIVIDE'
        },
        {
          state: codeSection,
          regexp: /^%/,
          token: 'MODULUS'
        },
        {
          state: codeSection,
          regexp: /^!/,
          token: 'NOT'
        },
        {
          state: codeSection,
          // notice escape string
          regexp: /^"(\\[\s\S]|[^\\"\n])*"/,
          action: function () {
            this.text = this.text.slice(1, -1).replace(/\\"/g, '"');
          },
          token: 'STRING'
        },
        {
          state: codeSection,
          // notice escape string
          regexp: /^'(\\[\s\S]|[^\\'\n])*'/,
          action: function () {
            this.text = this.text.slice(1, -1).replace(/\\'/g, '\'');
          },
          token: 'STRING'
        },
        {
          state: codeSection,
          regexp: /^\d+(?:\.\d+)?(?:e-?\d+)?/i,
          token: 'NUMBER'
        },
        {
          state: codeSection,
          regexp: /^=/,
          token: 'EQUALS'
        },
        {
          state: codeSection,
          regexp: /^\.\./,
          token: 'ID',
          action: function () {
            // wait for '/'
            this.pushState('ws');
          }
        },
        {
          state: ['ws'],
          regexp: /^\//,
          token: 'SEP',
          action: popState
        },
        {
          state: codeSection,
          regexp: /^\./,
          token: 'SEP'
        },
        {
          state: codeSection,
          regexp: /^\[/,
          token: 'L_BRACKET'
        },
        {
          state: codeSection,
          regexp: /^\]/,
          token: 'R_BRACKET'
        },
        {
          state: codeSection,
          regexp: /^\{/,
          token: 'L_BRACE'
        },
        {
          state: codeSection,
          regexp: /^\:/,
          token: 'COLON'
        },
        {
          state: codeSection,
          regexp: /^\?/,
          token: 'QUERY'
        },
        {
          state: codeSection,
          regexp: /^\}/,
          token: 'R_BRACE'
        },
        {
          state: codeSection,
          regexp: /^[a-zA-Z_$][a-zA-Z0-9_$]*/,
          token: 'ID'
        }
      ]
    }
  };
})();

/**
 * issues:
 *
 *  2013-06-17 reduce shift conflicts!
 *   {{n - 1}} expression: n-1
 *   {{n -1}} param n(-1)
 *   remove support for -1
 */
